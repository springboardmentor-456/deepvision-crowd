# -*- coding: utf-8 -*-
"""train.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/16jFU_0rjawj0ltYcG4CDNTvSQDGBJD3n
"""

import os, glob, torch, torch.nn as nn, scipy.io as sio
import numpy as np, cv2, matplotlib.pyplot as plt
from torch.utils.data import Dataset, DataLoader
from torchvision import models, transforms

class CrowdDataset(Dataset):
    def __init__(self, root, train=True, size=(256,256)):
        sub = "train_data" if train else "test_data"
        imgs = sorted(glob.glob(os.path.join(root, sub, "images", ".jpg")) +
                      glob.glob(os.path.join(root, sub, "images", ".png")))
        print(f"[{sub}] Found {len(imgs)} images in {os.path.join(root,sub,'images')}")
        self.imgs = imgs
        self.gts = [p.replace("images","ground-truth").replace(".jpg",".mat").replace(".png",".mat") for p in imgs]
        self.size, self.tf = size, transforms.ToTensor()

    def __len__(self): return len(self.imgs)

    def __getitem__(self, i):
        img=cv2.imread(self.imgs[i]); img=cv2.resize(img,self.size)
        mat=sio.loadmat(self.gts[i])
        pts=mat["image_info"][0,0][0,0][0]
        den=np.zeros(self.size,np.float32)
        for x,y in pts:
            if int(y*self.size[1]/img.shape[0])<self.size[1] and int(x*self.size[0]/img.shape[1])<self.size[0]:
                den[int(y*self.size[1]/img.shape[0]), int(x*self.size[0]/img.shape[1])]=1
        den=cv2.GaussianBlur(den,(15,15),4)
        return self.tf(img), torch.tensor(den).unsqueeze(0)

class CSRNet(nn.Module):
    def __init__(self):
        super().__init__()
        vgg=list(models.vgg16(pretrained=False).features.children())
        self.front=nn.Sequential(*vgg[:23])
        self.back=nn.Sequential(
            nn.Conv2d(512,512,3,1,2,dilation=2),nn.ReLU(),
            nn.Conv2d(512,512,3,1,2,dilation=2),nn.ReLU(),
            nn.Conv2d(512,512,3,1,2,dilation=2),nn.ReLU(),
            nn.Conv2d(512,256,3,1,2,dilation=2),nn.ReLU(),
            nn.Conv2d(256,128,3,1,2,dilation=2),nn.ReLU(),
            nn.Conv2d(128,64,3,1,2,dilation=2),nn.ReLU(),
            nn.Conv2d(64,1,1))
    def forward(self,x): return self.back(self.front(x))


def train_eval(root,epochs=1):
    device="cuda" if torch.cuda.is_available() else "cpu"
    tr=DataLoader(CrowdDataset(root,True),2,shuffle=True)
    te=DataLoader(CrowdDataset(root,False),2,shuffle=False)
    model,lossf,opt=CSRNet().to(device),nn.MSELoss(),torch.optim.Adam(CSRNet().parameters(),1e-5)

    for ep in range(epochs):
        model.train()
        for x,y in tr:
            x,y=x.to(device),y.to(device)
            loss=lossf(model(x),y)
            opt.zero_grad(); loss.backward(); opt.step()
        print(f"Epoch {ep+1} Loss {loss.item():.4f}")


    model.eval()
    x,y=next(iter(te))
    with torch.no_grad(): p=model(x.to(device)).cpu()
    for i in range(min(2,len(x))):
        plt.figure(figsize=(9,3))
        plt.subplot(1,3,1); plt.imshow(x[i].permute(1,2,0)); plt.title("Image"); plt.axis("off")
        plt.subplot(1,3,2); plt.imshow(y[i][0],cmap="jet"); plt.title("GT"); plt.axis("off")
        plt.subplot(1,3,3); plt.imshow(p[i][0],cmap="jet"); plt.title("Pred"); plt.axis("off")
        plt.show()

import os
root = r"/content/drive/MyDrive/archive (2)/ShanghaiTech/part_B"
for subdir, dirs, files in os.walk(root):
    print(subdir, len(files))