# -*- coding: utf-8 -*-
"""streamlitapp.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/16jFU_0rjawj0ltYcG4CDNTvSQDGBJD3n
"""

# Commented out IPython magic to ensure Python compatibility.
# %%writefile app_task4.py
# # ===============================
# # Milestone 4: Dashboard + Alerts
# # ===============================
# import os, smtplib, cv2, torch
# import numpy as np
# import streamlit as st
# from torchvision import transforms
# from PIL import Image
# from twilio.rest import Client
# import torch.nn as nn
# import torch.nn.functional as F
# 
# # -------------------------------
# # CONFIG
# # -------------------------------
# IMG_SZ = (256,256)
# DEVICE = torch.device("cuda" if torch.cuda.is_available() else "cpu")
# ALERT_THRESHOLD = int(os.getenv("ALERT_THRESHOLD", "150"))
# 
# # -------------------------------
# # Model (Tiny-MCNN from Milestone 3)
# # -------------------------------
# class TinyMCNN(nn.Module):
#     def __init__(self):
#         super().__init__()
#         self.net = nn.Sequential(
#             nn.Conv2d(3,16,3,1,1), nn.ReLU(), nn.MaxPool2d(2),
#             nn.Conv2d(16,32,3,1,1), nn.ReLU(), nn.MaxPool2d(2),
#             nn.Conv2d(32,64,3,1,1), nn.ReLU(),
#             nn.Conv2d(64,1,1)
#         )
#     def forward(self,x):
#         o=self.net(x)
#         if o.shape[2:] != x.shape[2:]:
#             o = F.interpolate(o, size=(x.shape[2], x.shape[3]), mode='bilinear', align_corners=False)
#         return o
# 
# # -------------------------------
# # Load model
# # -------------------------------
# MODEL_PATH = "/content/tiny_mcnn.pth"
# model = TinyMCNN().to(DEVICE)
# if os.path.exists(MODEL_PATH):
#     model.load_state_dict(torch.load(MODEL_PATH, map_location=DEVICE))
#     model.eval()
# else:
#     st.error("‚ùå Model file not found. Please place tiny_mcnn.pth in app folder.")
# 
# # -------------------------------
# # Preprocess function
# # -------------------------------
# def predict_count(img: Image.Image):
#     tf = transforms.ToTensor()
#     img_resized = img.resize(IMG_SZ)
#     t = tf(np.array(img_resized).astype('float32')/255.0).unsqueeze(0).to(DEVICE)
#     with torch.no_grad():
#         den = model(t).cpu().squeeze().numpy()
#     cnt = float(den.sum())
#     return cnt, den
# 
# # -------------------------------
# # Alert functions
# # -------------------------------
# def send_email(subject, body):
#     try:
#         EMAIL_USER = os.getenv("EMAIL_USER")
#         EMAIL_PASS = os.getenv("EMAIL_PASS")
#         ALERT_EMAIL = os.getenv("ALERT_EMAIL")
#         msg = f"Subject:{subject}\n\n{body}"
#         with smtplib.SMTP_SSL("smtp.gmail.com", 465) as smtp:
#             smtp.login(EMAIL_USER, EMAIL_PASS)
#             smtp.sendmail(EMAIL_USER, ALERT_EMAIL, msg)
#         st.success("üìß Email alert sent!")
#     except Exception as e:
#         st.error(f"Email failed: {e}")
# 
# def send_sms(body):
#     try:
#         TWILIO_SID = os.getenv("TWILIO_SID")
#         TWILIO_TOKEN = os.getenv("TWILIO_TOKEN")
#         TWILIO_FROM = os.getenv("TWILIO_FROM")
#         ALERT_PHONE = os.getenv("ALERT_PHONE")
#         client = Client(TWILIO_SID, TWILIO_TOKEN)
#         client.messages.create(body=body, from_=TWILIO_FROM, to=ALERT_PHONE)
#         st.success("üì± SMS alert sent!")
#     except Exception as e:
#         st.error(f"SMS failed: {e}")
# 
# # -------------------------------
# # Streamlit Dashboard
# # -------------------------------
# st.set_page_config(page_title="Crowd Counting Dashboard", layout="wide")
# st.title("üßë‚Äçü§ù‚Äçüßë Real-Time Crowd Counting Dashboard")
# 
# uploaded = st.file_uploader("Upload a crowd image", type=["jpg","png","jpeg"])
# if uploaded:
#     img = Image.open(uploaded).convert("RGB")
#     st.image(img, caption="Uploaded Image", use_column_width=True)
# 
#     # prediction
#     count, density = predict_count(img)
#     st.metric("Estimated Crowd Count", f"{count:.1f}")
#     status = "‚ö†Ô∏è High Crowd!" if count > ALERT_THRESHOLD else "‚úÖ Normal"
#     st.metric("Status", status)
# 
#     # show density heatmap
#     import matplotlib.pyplot as plt
#     import io
#     fig, ax = plt.subplots()
#     ax.imshow(density, cmap="jet")
#     ax.set_title("Predicted Density Map")
#     buf = io.BytesIO()
#     plt.savefig(buf, format="png")
#     st.image(buf)
# 
#     # alert button
#     if count > ALERT_THRESHOLD:
#         if st.button("üö® Send Alert"):
#             msg = f"Crowd Alert! Count reached {count:.1f}"
#             send_email("Crowd Alert", msg)
#             send_sms(msg)
#

# Commented out IPython magic to ensure Python compatibility.
# %%writefile app_task4.py
# # ===============================
# # Milestone 4: Dashboard + Alerts (Styled)
# # ===============================
# import os, smtplib, cv2, torch
# import numpy as np
# import streamlit as st
# from torchvision import transforms
# from PIL import Image
# from twilio.rest import Client
# import torch.nn as nn
# import torch.nn.functional as F
# 
# # -------------------------------
# # CONFIG
# # -------------------------------
# IMG_SZ = (256,256)
# DEVICE = torch.device("cuda" if torch.cuda.is_available() else "cpu")
# ALERT_THRESHOLD = int(os.getenv("ALERT_THRESHOLD", "150"))
# 
# # -------------------------------
# # Model (Tiny-MCNN from Milestone 3)
# # -------------------------------
# class TinyMCNN(nn.Module):
#     def __init__(self):
#         super().__init__()
#         self.net = nn.Sequential(
#             nn.Conv2d(3,16,3,1,1), nn.ReLU(), nn.MaxPool2d(2),
#             nn.Conv2d(16,32,3,1,1), nn.ReLU(), nn.MaxPool2d(2),
#             nn.Conv2d(32,64,3,1,1), nn.ReLU(),
#             nn.Conv2d(64,1,1)
#         )
#     def forward(self,x):
#         o=self.net(x)
#         if o.shape[2:] != x.shape[2:]:
#             o = F.interpolate(o, size=(x.shape[2], x.shape[3]), mode='bilinear', align_corners=False)
#         return o
# 
# # -------------------------------
# # Load model
# # -------------------------------
# MODEL_PATH = "/content/tiny_mcnn.pth"
# model = TinyMCNN().to(DEVICE)
# if os.path.exists(MODEL_PATH):
#     model.load_state_dict(torch.load(MODEL_PATH, map_location=DEVICE))
#     model.eval()
# else:
#     st.error("‚ùå Model file not found. Please place tiny_mcnn.pth in app folder.")
# 
# # -------------------------------
# # Preprocess function
# # -------------------------------
# def predict_count(img: Image.Image):
#     tf = transforms.ToTensor()
#     img_resized = img.resize(IMG_SZ)
#     t = tf(np.array(img_resized).astype('float32')/255.0).unsqueeze(0).to(DEVICE)
#     with torch.no_grad():
#         den = model(t).cpu().squeeze().numpy()
#     cnt = float(den.sum())
#     return cnt, den
# 
# # -------------------------------
# # Alert functions
# # -------------------------------
# def send_email(subject, body):
#     try:
#         EMAIL_USER = os.getenv("EMAIL_USER")
#         EMAIL_PASS = os.getenv("EMAIL_PASS")
#         ALERT_EMAIL = os.getenv("ALERT_EMAIL")
#         msg = f"Subject:{subject}\n\n{body}"
#         with smtplib.SMTP_SSL("smtp.gmail.com", 465) as smtp:
#             smtp.login(EMAIL_USER, EMAIL_PASS)
#             smtp.sendmail(EMAIL_USER, ALERT_EMAIL, msg)
#         st.success("üìß Email alert sent!")
#     except Exception as e:
#         st.error(f"Email failed: {e}")
# 
# def send_sms(body):
#     try:
#         TWILIO_SID = os.getenv("TWILIO_SID")
#         TWILIO_TOKEN = os.getenv("TWILIO_TOKEN")
#         TWILIO_FROM = os.getenv("TWILIO_FROM")
#         ALERT_PHONE = os.getenv("ALERT_PHONE")
#         client = Client(TWILIO_SID, TWILIO_TOKEN)
#         client.messages.create(body=body, from_=TWILIO_FROM, to=ALERT_PHONE)
#         st.success("üì± SMS alert sent!")
#     except Exception as e:
#         st.error(f"SMS failed: {e}")
# 
# # -------------------------------
# # Streamlit Styling
# # -------------------------------
# st.set_page_config(page_title="Crowd Counting Dashboard", layout="wide")
# 
# st.markdown("""
#     <style>
#     body {
#         background-color: #000000;
#         color: #FFFFFF;
#     }
#     .stApp {
#         background: linear-gradient(180deg, #111111, #000000);
#         color: white;
#     }
#     .stButton>button {
#         background-color: #FFD700 !important;
#         color: black !important;
#         font-weight: bold !important;
#         border-radius: 12px !important;
#         padding: 0.6em 1.2em !important;
#         border: none !important;
#         transition: 0.3s;
#     }
#     .stButton>button:hover {
#         background-color: #FFC300 !important;
#         transform: scale(1.05);
#     }
#     .stMetric {
#         background: #1c1c1c;
#         padding: 15px;
#         border-radius: 10px;
#         box-shadow: 0px 0px 8px rgba(255,215,0,0.6);
#     }
#     h1, h2, h3, h4 {
#         color: #FFD700 !important;
#     }
#     </style>
# """, unsafe_allow_html=True)
# 
# # -------------------------------
# # Dashboard
# # -------------------------------
# st.title("üßë‚Äçü§ù‚Äçüßë Real-Time Crowd Counting Dashboard")
# 
# uploaded = st.file_uploader("üì§ Upload a crowd image", type=["jpg","png","jpeg"])
# if uploaded:
#     img = Image.open(uploaded).convert("RGB")
#     st.image(img, caption="üì∑ Uploaded Image", use_column_width=True)
# 
#     # prediction
#     count, density = predict_count(img)
#     col1, col2 = st.columns(2)
#     with col1:
#         st.metric("Estimated Crowd Count", f"{count:.1f}")
#     with col2:
#         status = "‚ö†Ô∏è High Crowd!" if count > ALERT_THRESHOLD else "‚úÖ Normal"
#         st.metric("Status", status)
# 
#     # show density heatmap
#     import matplotlib.pyplot as plt
#     import io
#     fig, ax = plt.subplots()
#     ax.imshow(density, cmap="jet")
#     ax.set_title("Predicted Density Map", color="white")
#     ax.axis("off")
#     buf = io.BytesIO()
#     plt.savefig(buf, format="png", facecolor="black")
#     st.image(buf, caption="Density Heatmap")
# 
#     # alert button
#     if count > ALERT_THRESHOLD:
#         if st.button("üö® Send Alert"):
#             msg = f"Crowd Alert! Count reached {count:.1f}"
#             send_email("Crowd Alert", msg)
#             send_sms(msg)
#