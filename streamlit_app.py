# -*- coding: utf-8 -*-
"""Streamlit_App

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Cux5US9UJb329658o7dZ-LQ86F2jrbVE
"""

# Commented out IPython magic to ensure Python compatibility.
# %%writefile app_task4.py
# # ===============================
# # Milestone 4: Dashboard + Alerts
# # ===============================
# import os, smtplib, cv2, torch
# import numpy as np
# import streamlit as st
# from torchvision import transforms
# from PIL import Image
# from twilio.rest import Client
# import torch.nn as nn
# import torch.nn.functional as F
# 
# # -------------------------------
# # CONFIG
# # -------------------------------
# IMG_SZ = (256,256)
# DEVICE = torch.device("cuda" if torch.cuda.is_available() else "cpu")
# ALERT_THRESHOLD = int(os.getenv("ALERT_THRESHOLD", "150"))
# 
# # -------------------------------
# # Model (Tiny-MCNN from Milestone 3)
# # -------------------------------
# class TinyMCNN(nn.Module):
#     def __init__(self):
#         super().__init__()
#         self.net = nn.Sequential(
#             nn.Conv2d(3,16,3,1,1), nn.ReLU(), nn.MaxPool2d(2),
#             nn.Conv2d(16,32,3,1,1), nn.ReLU(), nn.MaxPool2d(2),
#             nn.Conv2d(32,64,3,1,1), nn.ReLU(),
#             nn.Conv2d(64,1,1)
#         )
#     def forward(self,x):
#         o=self.net(x)
#         if o.shape[2:] != x.shape[2:]:
#             o = F.interpolate(o, size=(x.shape[2], x.shape[3]), mode='bilinear', align_corners=False)
#         return o
# 
# # -------------------------------
# # Load model
# # -------------------------------
# MODEL_PATH = "/content/tiny_mcnn.pth"
# model = TinyMCNN().to(DEVICE)
# if os.path.exists(MODEL_PATH):
#     model.load_state_dict(torch.load(MODEL_PATH, map_location=DEVICE))
#     model.eval()
# else:
#     st.error("âŒ Model file not found. Please place tiny_mcnn.pth in app folder.")
# 
# # -------------------------------
# # Preprocess function
# # -------------------------------
# def predict_count(img: Image.Image):
#     tf = transforms.ToTensor()
#     img_resized = img.resize(IMG_SZ)
#     t = tf(np.array(img_resized).astype('float32')/255.0).unsqueeze(0).to(DEVICE)
#     with torch.no_grad():
#         den = model(t).cpu().squeeze().numpy()
#     cnt = float(den.sum())
#     return cnt, den
# 
# # -------------------------------
# # Alert functions
# # -------------------------------
# def send_email(subject, body):
#     try:
#         EMAIL_USER = os.getenv("EMAIL_USER")
#         EMAIL_PASS = os.getenv("EMAIL_PASS")
#         ALERT_EMAIL = os.getenv("ALERT_EMAIL")
#         msg = f"Subject:{subject}\n\n{body}"
#         with smtplib.SMTP_SSL("smtp.gmail.com", 465) as smtp:
#             smtp.login(EMAIL_USER, EMAIL_PASS)
#             smtp.sendmail(EMAIL_USER, ALERT_EMAIL, msg)
#         st.success("ðŸ“§ Email alert sent!")
#     except Exception as e:
#         st.error(f"Email failed: {e}")
# 
# def send_sms(body):
#     try:
#         TWILIO_SID = os.getenv("TWILIO_SID")
#         TWILIO_TOKEN = os.getenv("TWILIO_TOKEN")
#         TWILIO_FROM = os.getenv("TWILIO_FROM")
#         ALERT_PHONE = os.getenv("ALERT_PHONE")
#         client = Client(TWILIO_SID, TWILIO_TOKEN)
#         client.messages.create(body=body, from_=TWILIO_FROM, to=ALERT_PHONE)
#         st.success("ðŸ“± SMS alert sent!")
#     except Exception as e:
#         st.error(f"SMS failed: {e}")
# 
# # -------------------------------
# # Streamlit Dashboard
# # -------------------------------
# st.set_page_config(page_title="Crowd Counting Dashboard", layout="wide")
# st.title("ðŸ§‘â€ðŸ¤â€ðŸ§‘ Real-Time Crowd Counting Dashboard")
# 
# uploaded = st.file_uploader("Upload a crowd image", type=["jpg","png","jpeg"])
# if uploaded:
#     img = Image.open(uploaded).convert("RGB")
#     st.image(img, caption="Uploaded Image", use_column_width=True)
# 
#     # prediction
#     count, density = predict_count(img)
#     st.metric("Estimated Crowd Count", f"{count:.1f}")
#     status = "âš ï¸ High Crowd!" if count > ALERT_THRESHOLD else "âœ… Normal"
#     st.metric("Status", status)
# 
#     # show density heatmap
#     import matplotlib.pyplot as plt
#     import io
#     fig, ax = plt.subplots()
#     ax.imshow(density, cmap="jet")
#     ax.set_title("Predicted Density Map")
#     buf = io.BytesIO()
#     plt.savefig(buf, format="png")
#     st.image(buf)
# 
#     # alert button
#     if count > ALERT_THRESHOLD:
#         if st.button("ðŸš¨ Send Alert"):
#             msg = f"Crowd Alert! Count reached {count:.1f}"
#             send_email("Crowd Alert", msg)
#             send_sms(msg)
#